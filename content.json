{"meta":{"title":"郭鑫的个人博客","subtitle":"热爱技术 | 热爱生活","description":"我不在将这个世界与我所期待的，塑造的圆满世界比照，而是接受这个世界，爱它，属于它。","author":"Guo Xin","url":"https://bigbilii.github.io"},"pages":[{"title":"about","date":"2018-12-06T06:18:26.000Z","updated":"2018-12-07T08:24:44.149Z","comments":false,"path":"about/index.html","permalink":"https://bigbilii.github.io/about/index.html","excerpt":"","text":"姓名：郭鑫，1995年11月出生，男，重庆人。 email：im.guoxin@outlook.com 就读于重庆理工大学，计算机科学与技术专业，学士学位。 取得软考中级的软件设计师证书。 取得Oracle的OCJP认证。"},{"title":"tags","date":"2018-12-05T04:46:12.000Z","updated":"2018-12-05T04:46:57.862Z","comments":false,"path":"tags/index.html","permalink":"https://bigbilii.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-05T04:46:32.000Z","updated":"2018-12-05T04:47:17.766Z","comments":false,"path":"categories/index.html","permalink":"https://bigbilii.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"毕业设计-基于Shiro实现登录错误控制","slug":"毕业设计-基于Shiro实现登录错误控制","date":"2019-02-11T08:56:35.000Z","updated":"2019-02-11T09:31:08.917Z","comments":true,"path":"2019/02/11/毕业设计-基于Shiro实现登录错误控制/","link":"","permalink":"https://bigbilii.github.io/2019/02/11/毕业设计-基于Shiro实现登录错误控制/","excerpt":"","text":"前言接上篇博客，继续完成登录控制，本篇将介绍如何基于Shiro和Redis来实现登录错误控制。 项目地址：https://github.com/bigbilii/G-FoodShop 使用场景用户在登录后台管理时，往往会出现输入密码错误的情况，在输入密码错误到达一定次数时，会在一定时间内不允许再次尝试登录。也是为了放置密码暴力破解。 Shiro实现错误控制shiro提供了CredentialsMatcher这个接口来控制密码匹配过程，我们可以继承HashedCredentialsMatcher这个类来实现密码的加密和错误控制。 配置信息在配置信息中，配置了相关的密码加密信息，以及一个cacheManager，这个缓存管理器使用的是上篇的缓存管理器，用来记录登录错误次数的记录。 12345678910111213141516&lt;!-- 自定义Realm --&gt; &lt;bean id=&quot;myRealm&quot; class=&quot;me.guoxin.manager.shiro.MyRealm&quot;&gt; &lt;!-- 使用credentialsMatcher实现密码验证服务 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;me.guoxin.manager.shiro.RetryLimitHashedCredentialsMatcher&quot;&gt; &lt;!-- 加密算法名称 --&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt; &lt;!-- 加盐次数 --&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt; &lt;!-- 是否储存散列后的密码为16进制 --&gt; &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt; &lt;!-- 缓存管理器 --&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;cacheManager&quot;/&gt; &lt;/bean&gt; RetryLimitHashedCredentialsMatcher实现逻辑非常简单，即如果密码输入正确清除cache中的记录；否则cache中的重试次数+1，如果超出5次那么抛出异常表示超出重试次数了，直到缓存清除（也就是之前配置的1个小时），也可以在建一个单独的缓存来控制密码输入，但为了方便，也就直接用之前的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 登录次数验证 + 密码加密验证 * 密码相关参数由配置文件配置 */public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher &#123; private Cache&lt;String, AtomicInteger&gt; passwordRetryCache; /** * 获取 passwordRetryCache 缓存 * * @param cacheManager 配置文件注入 CacheManager */ public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) &#123; passwordRetryCache = cacheManager.getCache(&quot;passwordRetryCache&quot;); &#125; @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws IException &#123; /*获取用户手机号*/ String userPhone = token.getPrincipal().toString(); /*获取已重试次数*/ AtomicInteger retryCount = passwordRetryCache.get(userPhone); /*第一次*/ if (retryCount == null) &#123; retryCount = new AtomicInteger(); passwordRetryCache.put(userPhone, retryCount); &#125; if (retryCount.incrementAndGet() &gt; 5) &#123; throw new ExcessiveAttemptsException(); &#125; passwordRetryCache.put(userPhone, retryCount); /*否则走判断密码逻辑*/ boolean matches = super.doCredentialsMatch(token, info); if (matches) &#123; /*clear retry count*/ passwordRetryCache.remove(userPhone); &#125; return matches; &#125;&#125; 总结通过上述的代码，能够实现shiro+redis的登录错误管理。这点来说也是十分必要的，能够有效解决暴力破解密码，在下篇中，将会介绍单一登录与踢人。 题外话最近春节，收获了一笔小钱，故将想买很久的显示器纳入了购入设备中。结合了许多显示器的评测和自己的需求，最终买了AOC的Q1790PQ。 需求如下： 27寸以上（原用15寸笔记本，由于屏幕太小，字体很小，眼睛不舒服，而且屏幕摆不了很多窗口，故想要27寸的显示器） 2k分辨率（选择区间还有1080/4k的，但由于平时编码较多，分辨率越高，显示效果越好，字体看起来也越舒服，但27寸上4k的话，效果提升不明显（非亲自体验），所以选择性价比较高的2k） 16：9比例（由于现目前钱不多，故不会买太好的显示器，一旦以后再买一个显示器，这台会变成副屏，16：9的竖置比18：9效果好） ips面板（面板的选择不是最主要的，但对于曲面的va屏和一般的tn屏来讲，ips的可视角度令我心仪） 根据上面的需求，结合我自己的钱，最终买入了这款，京东春节送货也是1天到，买来除了左下角的漏光之外，没有坏点，没有磕碰，总体购买和使用体验很好。以后的话，可能会购入V站用户推荐的dell u系列，但AOC这台给我的体验非常好，总归一分钱一分货，这台显示器值。","categories":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/tags/Shiro/"},{"name":"Redis","slug":"Redis","permalink":"https://bigbilii.github.io/tags/Redis/"}]},{"title":"毕业设计-Shiro-Redis与记住我整合应用","slug":"毕业设计-Shiro-Redis与记住我整合应用","date":"2019-02-03T08:38:40.000Z","updated":"2019-02-11T08:52:29.664Z","comments":true,"path":"2019/02/03/毕业设计-Shiro-Redis与记住我整合应用/","link":"","permalink":"https://bigbilii.github.io/2019/02/03/毕业设计-Shiro-Redis与记住我整合应用/","excerpt":"","text":"前言这段时间临近过年，稍微放松了下。但还是稍微做了点事情，把毕业设计的框架设计了下，总体分为前台和后台两部分，这段时间把后台管理的登录和权限控制实现了。 主要完成了下面的功能： redis实现Shiro的缓存和session控制 在线数控制与踢人 密码错误控制与锁定 验证码 记住我 项目地址：https://github.com/bigbilii/G-FoodShop Shiro+RedisShiro提供了org.apache.shiro.cache.CacheManager、org.apache.shiro.cache.Cache等接口来让我们做缓存和Session的管理，可以利用Redis、memcache等的高速缓存或者mysql等的数据库来做缓存。一般用Redis，方便好用。 那我也是用的Redis，本来在网上找了教程，自己实现redis的集成，但发现了已经由大神做好了插件，则我就可以直接用。 依赖添加12345&lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt; Spring配置信息1234567891011121314151617181920212223242526272829&lt;!-- 配置Shiro RedisManager --&gt; &lt;bean id=&quot;redisManager&quot; class=&quot;org.crazycake.shiro.RedisManager&quot;&gt; &lt;property name=&quot;host&quot; value=&quot;192.168.33.10:6379&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Shiro 缓存管理 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.crazycake.shiro.RedisCacheManager&quot;&gt; &lt;property name=&quot;redisManager&quot; ref=&quot;redisManager&quot;/&gt; &lt;property name=&quot;principalIdFieldName&quot; value=&quot;phone&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Shiro 会话DAO层 通过redis --&gt; &lt;bean id=&quot;redisSessionDAO&quot; class=&quot;org.crazycake.shiro.RedisSessionDAO&quot;&gt; &lt;property name=&quot;redisManager&quot; ref=&quot;redisManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Shiro 会话管理 --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;redisSessionDAO&quot;/&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;myRealm&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt; 上面配置完成之后，利用log4j可以看出对redis的读取。 值得注意的是，在cacheManager的配置中，有个参数principalIdFieldName，其含义是Shiro-redis需要一个id字段来识别Redis中的授权对象。 借用官方文档的案例说明。 1234567@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken)token; UserInfo userInfo = new UserInfo(); userInfo.setUsername(usernamePasswordToken.getUsername()); return new SimpleAuthenticationInfo(userInfo, &quot;123456&quot;, getName());&#125; Shiro-redis需要从UserInfo中获取一个唯一标识来标记它12345678910111213public class UserInfo implements Serializable&#123; private Integer userId private String username; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserId() &#123; return this.userId; &#125;&#125; 则在spring配置中，需要配置唯一标识1&lt;property name=&quot;principalIdFieldName&quot; value=&quot;userId&quot; /&gt; Shiro-redis就会去调用getUserId()方法。 记住我很多网站在登录时都会提供记住我这个功能，shiro也提供了接口。 配置信息12345678910111213141516171819202122232425262728&lt;!-- 会话Cookie模板 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;SID&quot;/&gt; &lt;!-- 如果设置为true，则客户端不会暴露给服务端脚本代码，有助于减少某些类型的跨站脚本攻击 --&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot;/&gt;&lt;!-- maxAge=-1表示浏览器关闭时失效此Cookie --&gt; &lt;/bean&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;constructor-arg value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;&lt;!-- 30天 --&gt; &lt;/bean&gt; &lt;!-- rememberMe管理器 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;!-- cipherKey是加密rememberMe Cookie的密匙，默认AES算法 --&gt; &lt;property name=&quot;cipherKey&quot; value=&quot;#&#123;T(org.apache.shiro.codec.Base64).decode(&apos;4AvVhmFLUs0KTA3Kprsdag==&apos;)&#125;&quot;/&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;myRealm&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt; 值得注意的是，这里配置了两个Cookie，一个配置在rememberMeManager，另一个配置在sessionManager，原因是sessionIdCookie是用来替换默认的JESSIONID，否则原本默认的JESSIONID会影响rememberMeCookie的判断，导致失败。 Controller与VO修改新增remeber字段，用于记录前端是否勾选记住我1234567891011121314151617181920212223242526272829303132333435363738public class Account &#123; /** * 账号|手机号 */ private String phone; /** * 密码 */ private String password; /** * 记住我 */ private boolean remember; public String getPhone() &#123; return phone; &#125; public void setPhone(String username) &#123; this.phone = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public boolean isRemember() &#123; return remember; &#125; public void setRemember(boolean rememberme) &#123; this.remember = rememberme; &#125;&#125; 在生成UsernamePasswordToken时，加入记住我参数123456789101112131415161718/** * 登录 * POST * * @param account 登录信息 * @return * @throws Exception */ @PostMapping(value = &quot;/user/login&quot;) public Result login(@RequestBody Account account, HttpServletRequest request) &#123; UsernamePasswordToken token = new UsernamePasswordToken(account.getPhone(), account.getPassword(), account.isRemember()); log.info(&quot;login：正在登录中，登录信息为：&quot; + account); Subject subject = SecurityUtils.getSubject(); subject.login(token); log.info(&quot;login：登录成功&quot;); return new ResultUtil&lt;Object&gt;().setData(null, &quot;登录成功&quot;); &#125;","categories":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/tags/Shiro/"},{"name":"Redis","slug":"Redis","permalink":"https://bigbilii.github.io/tags/Redis/"}]},{"title":"日常坑记录-Centos配置Redis","slug":"日常坑记录-Centos配置Redis","date":"2019-01-17T14:37:01.000Z","updated":"2019-01-17T15:30:21.530Z","comments":true,"path":"2019/01/17/日常坑记录-Centos配置Redis/","link":"","permalink":"https://bigbilii.github.io/2019/01/17/日常坑记录-Centos配置Redis/","excerpt":"","text":"前言在完成上一个Shiro+SSM小demo之后，我开始了Redis的学习，当我在【Vagrant+VirtualBox】这篇文章中里安装的Centos里安装Redis时，遇到了几个问题，解决了一阵子，故在这里记录下。 环境介绍系统环境在Vagrant+VirtualBox搭建Linux开发环境中安装了Centos7. Redis安装过程 安装gcc环境 1$ yum install gcc-c++ 安装Redis 1234$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz$ tar xzf redis-5.0.3.tar.gz$ cd redis-5.0.3$ make 启动redis 12$ cd src$ ./redis-server 验证 1$ ./redis-cli 修改配置文件，以守护进程方式执行 123456$ vim ../redis.conf修改daemonize yes$ ./redis-server ../redis.conf 问题1：Centos打开端口问题问题通过上面步骤，可以在虚拟机里正常启动redis，但在宿主机上连接虚拟机的6379端口却失败。 解决过程 启动Redis正常 添加防火墙过滤端口(必须添加) 1# firewall-cmd --zone=public --add-port=6379/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重启防火墙 1# firewall-cmd --reload 失败，telnet连接不上。 重启虚拟机失败 关闭防火墙 1234停止： # systemctl disable firewalld禁用： # systemctl stop firewalld 失败，又开启防火墙 解决 打开监听服务，查看6379端口是否被监听。 发现问题，服务运行在127.0.0.1：6379端口上，然后这个ip地址不能被外部所访问的，故修改redis.conf文件123bind: 0.0.0.0或者#bind: 127.0.0.1 成功！ 问题2：Redis开机启动失败每次开机都需要手动启动redis，故想配置开机启动。 问题根据网上配置流程，配置启动失败。 解决过程 将Redis的server和cli脚本文件放入相应文件夹下（非必要） 12345# cp /home/vagrant/redis-5.0.3/src/redis-server /usr/local/redis# cp /home/vagrant/redis-5.0.3/src/redis-cli /usr/local/redis# cp /home/vagrant/redis-5.0.3/redis.conf /usr/local/redis 配置redis.service文件信息（需要添加） 1234567891011121314# vim /usr/lib/systemd/system/redis.service[Unit]Description=Redis ServerAfter=network.target[Service]ExecStart=/usr/local/redis/redis-server /usr/local/redis/redis.confExecStop=/usr/local/redis/redis-cli shutdownRestart=always[Install]WantedBy=multi-user.target 重新加载 1# systemctl daemon-reload 启动redis开机服务 1234设置Redis服务开机启动# systemctl enable redis启动Redis服务# systemctl start redis 查看启动状态 1# systemctl status redis 启动失败 解决修改引入的redis.conf配置文件1daemonize no 或者在redis.service文件中修改启动参数1ExecStart=/usr/local/redis/redis-server /usr/local/redis/redis.conf --daemonize no 启动服务，成功！ 问题3：语言问题问题在我解决上两个问题的时候，我发现系统打出的log是德语，搞得我看不懂 解决过程 查看当前语言1locale 发现为德语 修改语言1localectl set-locale LANG=en_US.UTF8 修改成功！","categories":[{"name":"Centos","slug":"Centos","permalink":"https://bigbilii.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://bigbilii.github.io/tags/Centos/"},{"name":"Redis","slug":"Redis","permalink":"https://bigbilii.github.io/tags/Redis/"}]},{"title":"Shiro-ssm项目集成与实现","slug":"Shiro-ssm项目集成与实现","date":"2019-01-16T04:07:03.000Z","updated":"2019-01-16T09:25:40.804Z","comments":true,"path":"2019/01/16/Shiro-ssm项目集成与实现/","link":"","permalink":"https://bigbilii.github.io/2019/01/16/Shiro-ssm项目集成与实现/","excerpt":"","text":"前言学习技术，最重要的是实践。 本着上面的原则，学习玩shiro基本知识之后，我也动手写了一个小demo，来熟悉下shiro。 在这个小项目中，需求是实现普通用户和管理员的权限分离，管理员可以对普通用户进行CRUD，普通用户只能登录。 这个项目中，涉及到以下技术点: SSM（Spring\\SpringMVC\\Mybatis） Shiro的授权和角色认证 Shiro自定义Realm Shiro加密 RBAC数据库设计 RESTFul api设计 RBAC数据库设计来自wiki的解释： 以角色为基础的访问控制（英语：Role-based access control，RBAC），是资讯安全领域中，一种较新且广为使用的访问控制机制，其不同于强制访问控制以及自由选定访问控制直接赋予使用者权限，而是将权限赋予角色. 之所以采用RBAC设计模式来进行权限管理的数据库设计，是因为我们可以避免让主体直接与权限关联，而通过角色来进行连接，它通过主体-角色-权限这三张表，来实现主体与角色，角色与权限的关系。 所以我创建了以下五张表： user：用户表 role：角色表 promission：权限表 user_role：用户角色关系表 role_promission：角色权限关系表 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950create table user( id int auto_increment primary key, username varchar(100) null comment &apos;用户名&apos;, password varchar(100) null comment &apos;密码&apos;, salt varchar(100) null, constraint user_username_uindex unique (username)) comment &apos;用户表&apos;;create table role( id int auto_increment primary key, name varchar(20) null comment &apos;权限名称&apos;, description varchar(50) null comment &apos;权限描述&apos;) comment &apos;角色表&apos;;create table permission( id int auto_increment primary key, name varchar(20) null comment &apos;权限名称&apos;, description varchar(50) null comment &apos;权限描述表&apos;) comment &apos;权限表&apos;;create table user_role( user_id int null, role_id int null, constraint user_role_rid_fk foreign key (role_id) references role (id), constraint user_role_uid_fk foreign key (user_id) references user (id)) comment &apos;用户角色表&apos;;create table role_premission( role_id int null, permission_id int null, constraint role_premission_pid_fk foreign key (permission_id) references permission (id), constraint role_premission_uid_fk foreign key (role_id) references role (id)); Shiro遇到Spring在SSM架构中，通过XMl文件的方式来设置相关配置信息。由于是学习Shiro，所以其他的Spring相关的配置就不具体展示。 Web.xml在web.xml中配置shiro拦截器，以拦截所有的请求，通过shiro来进行权限管理。注意：下面我添加了加载spring配置文件的配置信息，注意配置文件的命名格式需要为spring-*.xml1234567891011121314151617181920212223&lt;!-- shiro 安全过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!--加载spring配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; spring-shiro.xml在spring-shiro.xml中，配置了shiro所有在spring中需要配置的相关信息，下面来具体看一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;!--Web拦截器--&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!--安全认证管理器--&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!--登录页面--&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;!-- 自定义的过滤器链，从上向下执行，一般将`/**`放到最下面 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!--静态资源--&gt; /static/** = anon /lib/** = anon /js/** = anon &lt;!--登录页面与请求--&gt; /login.jsp = anon /login = anon &lt;!--登出--&gt; /logout = logout &lt;!--登录后可访问主页--&gt; /index.jsp = user &lt;!--所有请求--&gt; /** = user &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--Shiro安全管理器--&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;/bean&gt; &lt;!--自定义Realm--&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;com.bigbilii.realm.UserRealm&quot;&gt; &lt;!-- 使用credentialsMatcher实现密码验证服务 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt; &lt;/bean&gt; &lt;!--密码匹配过程--&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher &quot;&gt; &lt;!--加密算法名称--&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt; &lt;!--加盐次数--&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt; &lt;!--是否存储散列后的密码为16进制--&gt; &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro生命周期处理器--&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;&lt;/beans&gt; 在配置完这些之后，shiro的spring配置文件也基本告一段落，在上面的配置信息中，有两个值得注意的地方。一个是filterChainDefinitions自定义拦截链，这个是从上往下执行的，也就是执行第一次匹配成功的结果，下面是部分默认拦截器的说明：|拦截器名|说明||—|—- ||authc|基于表单的拦截器，其拦截的请求必须是通过登录验证的||logout|退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/）;示例“/logout=logout”||user|用户拦截器，用户已经身份验证/记住我登录的都可；示例“/=user”||anon|匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例“/static/=anon”| 另外一个是userRealm自定义realm。 自定义RealmShiro的SecurityManager从Realm中获取安全数据，而Shiro自带了一些Realm可以是我们能够提供安全数据给Shiro做认证，但当数据较为复杂，自带的Realm功能就不能满足业务需求，这时就需要自定义Realm。 下面的UserRealm要实现授权和认证两个功能，所以继承了AuthorizingRealm类，因为它继承了AuthenticatingRealm类，所以可以同时实现授权和认证两个功能，需要对doGetAuthorizationInfo()和doGetAuthenticationInfo()方法进行重写。下面是源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class UserRealm extends AuthorizingRealm &#123; @Resource UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;权限校验&quot;); String username = (String) principalCollection.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); Set&lt;String&gt; role = new HashSet&lt;String&gt;(); /*获取角色信息*/ List&lt;Role&gt; roles = userService.findRoles(username); for (Role r : roles)&#123; role.add(r.getname()); &#125; System.out.println(&quot;!!!!!!!!!!! 添加role&quot; + role); authorizationInfo.setRoles(role); /*获取权限信息*/ List&lt;Permission&gt; permissions = userService.findPermissions(username); Set&lt;String&gt; permission = new HashSet&lt;String&gt;(); for (Permission p : permissions)&#123; permission.add(p.getname()); &#125; System.out.println(&quot;!!!!!!!!!!! 添加permission&quot; + permission); authorizationInfo.setStringPermissions(permission); /*返回角色和权限信息，交给AuthenticationRealm进行角色权限匹配*/ return authorizationInfo; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;权限校验&quot;); String username = (String) authenticationToken.getPrincipal(); /*获取用户信息*/ User user = userService.findByName(username); if (user == null) &#123; throw new UnknownAccountException(); &#125; /*返回认证信息，交给AuthenticationRealm进行密码匹配*/ SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( user.getUsername(), user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), getName() ); return authenticationInfo; &#125;&#125; 大部分流程都是用注解标注了。下面来看一下具体UserRealm是如何工作的。 登录认证123456789101112131415161718192021222324public class LoginController &#123; /** * 登录验证 * * @param username 用户名 * @param password 密码 * @return */ @PostMapping public Result login(@RequestParam(value = &quot;username&quot;, required = false) String username, @RequestParam(value = &quot;password&quot;, required = false) String password) &#123; System.out.println(&quot;账号:&quot; + username + &quot;,密码:&quot; + password); if (username != null &amp;&amp; password != null) &#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); subject.login(token); return Result.message(200,&quot;登录成功&quot;); &#125; else &#123; return Result.message(401,&quot;用户名或密码错误&quot;); &#125; &#125;&#125; 具体流程： 从请求中回去了提交的username和password，将获取到的用户名和密码设置成Token。然后回去主体Subject，因为在Spring的配置文件中已经初始化SecurityManager和设置了UserRealm，所以可以直接获取主体。 调用login()方法，然后SecurityManager会委派Authenticator调用自定义Realm的认证方法，也就是我们重写的doGetAuthenticationInfo()方法，其中的authenticationToken参数也就是我们之前封装的token。 进入到我们的方法后，我们通过service服务层去获取数据库的信息，获取到数据库的账号密码，注意：数据库的密码是加密处理的，所以取到密码和前台传入的明文密码不能匹配。 获取到数据库信息之后，将信息封装到SimpleAuthenticationInfo实例，返回给Authenticator做密码认证，因为在配置文件中，设置了credentialsMatcher密码认证过程，所以Authenticator也会去调用这个密码认证过程，将token中储存的明文密码进行加密，与数据库的加密密码进行匹配，从而认证。 加密在上面的登录验证过程中，多次提到了密码加密问题，这个问题也是非常常见的，在实际项目中，不可能使用明文密码进行存储，都会用到加密技术，而Shiro也支持加密。 具体的加密技术不是本文的重点，所以不会过多介绍。下面是我封装的一个加密工具，用于为用户进行加密处理。 1234567891011121314151617181920212223@Componentpublic class PasswordHelper &#123; private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator(); private String algorithName = &quot;MD5&quot;; private int hashInterations = 2; //加密算法 public void encryptPassword(User user)&#123; if (user.getPassword() != null)&#123; //对user对象设置盐：salt；这个盐值是randomNumberGenerator生成的随机数 user.setSalt(randomNumberGenerator.nextBytes().toHex()); //调用SimpleHash指定散列算法参数：1、算法名称；2、用户输入的密码；3、盐值（随机生成的）；4、迭代次数 String newPassword = new SimpleHash( algorithName, user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), hashInterations).toHex(); user.setPassword(newPassword); &#125; &#125;&#125; 具体流程： 通过RandomNumberGenerator随机生成盐值，并设置成用户的盐值 通过SimpleHash实例来构造一个加密密码，参数中，第三个盐值是【用户名+随机盐值】 设置用户的加密密码 值得注意的是：algorithName和hashInterations是需要提前约定的，这样生成用户的密码的加密方式和Shiro配置的credentialsMatcher密码认证过程的加密方式才能一致。 授权首先，在用户表中添加两个用户，一个当管理员，一个当普通用户. 然后在数据库插入几条授权需要用到的信息，sql如下 1234567891011121314151617181920212223242526insert into permission values(1,&apos;resource:create&apos;,&apos;用户新增&apos; );insert into permission values(2,&apos;user:update&apos;,&apos;用户修改&apos; );insert into permission values(3,&apos;user:delete&apos;,&apos;用户删除&apos; );insert into permission values(4,&apos;user:view&apos;, &apos;用户查看&apos; );insert into permission values(5,&apos;role:update&apos;, &apos;角色更新&apos;);insert into permission values(6,&apos;role:delete&apos;, &apos;角色删除&apos;);insert into permission values(7,&apos;role:create&apos;, &apos;角色创建&apos;);insert into permission values(8,&apos;role:view&apos;, &apos;角色查看&apos;);insert into permission values(9,&apos;news:view&apos;, &apos;新闻查看&apos;);insert into role values(1,&apos;admin&apos;,&apos;管理员&apos;);insert into role values(2,&apos;user&apos;,&apos;普通用户&apos;);insert into role_premission values(1,1);insert into role_premission values(1,2);insert into role_premission values(1,3);insert into role_premission values(1,4);insert into role_premission values(1,5);insert into role_premission values(1,6);insert into role_premission values(1,7);insert into role_premission values(1,8);insert into role_premission values(1,9);insert into role_premission values(2,9);insert into user_role values(1,1);insert into user_role values(2,2); 然后来看下我们的UserController，这里采用的是RESTFul设计1234567891011121314151617181920212223242526272829303132333435@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; @RequiresPermissions(&quot;user:insert&quot;) @PostMapping public Result insert(@RequestBody User user) &#123; System.out.println(user); userService.insert(user); return Result.message(200, &quot;创建用户成功&quot;); &#125; @RequiresPermissions(&quot;user:delete&quot;) @DeleteMapping public Result delete(String username) &#123; System.out.println(&quot;删除&quot;); userService.delete(username); return Result.message(200, &quot;删除用户成功&quot;); &#125; @RequiresPermissions(&quot;user:view&quot;) @GetMapping public Result query() &#123; System.out.println(&quot;查询&quot;); List&lt;User&gt; users = userService.query(); return Result.message(200, &quot;查询用户成功&quot;).add(&quot;users&quot;,users); &#125;&#125; 通过@RequiresPermissions()这个注解来控制权限登录，除了这个注解，还有其他的授权控制注解。| | ||-|-||@RequiresAuthentication|表示当前Subject已经通过login身份验证；即Subject.isAuthenticated() == true；否则就拦截||@RequiresUser|表示当前Subject已经通过login身份验证或通过记住我登录；否则就拦截||@RequiresGuest|表示当前Subject没有身份验证或通过记住我登录过，即是游客身份||@RequiresRoles(admin)|表示当前Subject需要admin角色||@RequiresPermissions(“user:insert”)|表示当前Subject需要拥有”user:insert”权限| 值得注意的是：某些shiro注解需要AOP功能进行判断,所以在springmvc配置文件中开启shiro spring AOP的支持1234&lt;aop:config proxy-target-class=&quot;true&quot;/&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; 然后回过头来看下我们的UserReaml的doGetAuthorizationInfo方法。 在该方法中，通过service获取到role信息和premission信息，其实可以不用回去role信息的，因为我们在controller层是通过premission来控制权限的。 问题 在这里的时候，我发现了一个问题：我在设计controller时，通过premisson来控制，所以需要在数据库获取permission，但在我们之前的表设计，通过用户名来获取到permission，需要5张表连接，故在这里可以自行进行优化。 关于RESTFulRESTFul是一种接口开发设计规范，是Representational State Transfer的缩写，其意为“表现层状态转化”，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。REST认为，每一个URL都是一种资源，所有的操作都是对资源的操作，而不同的操作主要使用HTTP动词来表示。|方法| 含义||-|-||GET（SELECT）| 从服务器取出资源（一项或多项）||POST（CREATE） |在服务器新建一个资源||PUT（UPDATE）| 在服务器更新资源（客户端提供改变后的完整资源）||DELETE（DELETE） |从服务器删除资源||HEAD |获取资源的元数据||OPTIONS |获取信息，关于资源的哪些属性是客户端可以改变的| 总结这次通过Shiro配合SSM框架写了个小demo，但可以看到有个明显的性能问题：每次到需要处理权限问题的请求的时候，都需要去数据库里获取相应的信息，这对性能的消耗很大，所以在之后会加入缓存的处理。由于我现在对缓存的运用不是很熟悉，在之后的学习中，会对这里的进行升级。 源码：https://github.com/bigbilii/Shiro","categories":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/tags/Shiro/"},{"name":"Spring","slug":"Spring","permalink":"https://bigbilii.github.io/tags/Spring/"},{"name":"RBAC","slug":"RBAC","permalink":"https://bigbilii.github.io/tags/RBAC/"}]},{"title":"Shiro-授权管理","slug":"Shiro-授权管理","date":"2019-01-12T02:50:10.000Z","updated":"2019-01-12T06:55:18.955Z","comments":true,"path":"2019/01/12/Shiro-授权管理/","link":"","permalink":"https://bigbilii.github.io/2019/01/12/Shiro-授权管理/","excerpt":"","text":"授权管理授权管理，也就是访问控制，是控制主体对指定资源的访问权限，简单地说，就是谁有权访问什么。 Examples of authorization checks are: Is the user allowed to look at this webpage, edit this data, view this button, or print to this printer? Those are all decisions determining what a user has access to. 权限权限是安全策略中的原子级别，描述了资源类型和可执行操作。 常见的资源操作就是CRUD，也就是创建、读取、更新、删除。 一些权限示例 打开一个文件 查看“/ user / list”网页 打印文件 删除’jsmith’用户 角色角色是一个权限的集合，是为简化权限的用户管理和用户管理。 值得注意的是，Shiro同时支持的两种角色。 隐式角色：通过验证角色来验证用户有没有操作权限，粒度为角色。例如：如果你是管理员，你则有创建和删除的权限，而如果你是浏览者，你则只有查询的权限。 显式角色：通过验证权限来验证用户有没有操作权限，粒度为权限。例如：如果你有删除权限，则你可以执行删除操作，如果你有查询权限，则你可以执行查询。 Shiro中的授权方式Shiro的授权可以分为四种方式： 编程方式：在程序中以if和else代码块的方式执行授权检查 JDK注解：通过授权注解的方式附加到Java程序中 JSP/GSP TagLibs：可以在jsp或gsp页面中根据权限进行页面输出 在下面的代码中，将会检查用户是否具有admin权限。可以看出不同方式的区别。 程序化授权12345678Subject subject = SecurityUtils.getSubject();/*hasRole()方法判断用户的角色*/if (subject.hasRole(&quot;admin&quot;)) &#123; //具有管理员权限&#125; else &#123; //不具有管理员权限&#125; 上面代码通过隐式角色的方式来验证。为了以后更好的维护代码，下面将会采用显式的方法来实现。 123456789Subject subject = SecurityUtils.getSubject();/*基于字符串检查权限*/String perm = &quot;admin:delete&quot;;if (subject.isPermitted(perm)) &#123; //具有管理员的删除权限&#125; else &#123; //不具有管理员的删除权限&#125; 基于字符串的权限检查，好处是简单，快速通过字符串构造权限，缺点是没有类型安全。 如果需要复杂的权限功能，则需要基于权限接口实现自己的权限对象，这里就不叙述。 注解授权使用注解授权，需要应用程序启动AOP支持。有不同的AOP框架，在Shiro文档中，找到了对不同框架的帮助文档。 对于AspectJ，您可以查看我们的AspectJ示例应用程序。 对于Spring，您可以查看我们的Spring Integration文档。 对于Guice，您可以查看我们的Guice Integration文档。 和上面一样，采用权限和角色实现注解检查。 12345/*权限检查*/@RequiresPermissions(&quot;admin:delete&quot;)‏public void deleteGoods(UUID id ) &#123; //删除物品&#125; 12345/*角色检查*/@RequiresPermissions(&quot;admin&quot;)‏public void deleteGoods(UUID id ) &#123; //删除物品&#125; 上述如果角色权限正确，执行方法；如果错误，抛出异常。 JSP TagLib授权对于基于JSP/GSP的Web应用，Shiro提供了一个标签库使用。 具体使用代码如下，也是采用闲事和隐式两种方式。12345678910111213141516171819/*引入标签库*/&lt;%@ taglib prefix=&quot;shiro&quot; uri=http://shiro.apache.org/tags %&gt;&lt;html&gt;&lt;body&gt; /*具有admin的删除权限*/ &lt;shiro:hasPermission name=&quot;admin:delete&quot;&gt; &lt;a href=&quot;goods/delete&quot;&gt; 点击删除 &lt;/a&gt; &lt;/shiro:hasPermission&gt; /*是否为admin角色*/ &lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;a href=&quot;goods/delete&quot;&gt; 点击删除 &lt;/a&gt; &lt;/shiro:hasRole&gt;&lt;/body&gt;&lt;/html&gt; 简单例子本例子延续前篇的【简单例子】使用，如果没有看过，则自行跳转查看。 Shrio-权限管理的简单例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.bigbilii.test;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationException;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.realm.jdbc.JdbcRealm;import org.apache.shiro.realm.text.IniRealm;import org.apache.shiro.subject.Subject;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class AuthenticationTest &#123; /*简单的Realm*/ SimpleAccountRealm realm = new SimpleAccountRealm(); JdbcRealm jdbcRealm = new JdbcRealm(); IniRealm iniRealm = new IniRealm(); /*向Realm添加用户认证信息*/ @Before public void addUser() &#123; /* 添加用户，并设置成admin、user两个角色，既Bilii同时具有admin和user角色的权限*/ realm.addAccount(&quot;Bilii&quot;, &quot;123&quot;, &quot;admin&quot;, &quot;user&quot;); &#125; @Test public void testAuthentication() &#123; /*构建SecurityManager环境*/ DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); /*添加Realm*/ defaultSecurityManager.setRealm(realm); /*主体提交认证信息*/ SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;Bilii&quot;, &quot;123&quot;); try &#123; /*登录（验证身份）*/ subject.login(token); &#125; catch (AuthenticationException e) &#123; /*登录失败*/ System.out.println(&quot;登录失败&quot;); e.printStackTrace(); &#125; Assert.assertEquals(true, subject.isAuthenticated()); try &#123; /*检查是否具有admin权限*/ subject.checkRole(&quot;admin&quot;); &#125; catch (AuthorizationException e) &#123; /*登录失败*/ System.out.println(&quot;不具备admin的权限&quot;); e.printStackTrace(); &#125; try &#123; /*检查是否同时具有admin和user权限*/ subject.checkRoles(&quot;admin&quot;, &quot;user&quot;); &#125; catch (AuthorizationException e) &#123; /*登录失败*/ System.out.println(&quot;不同时具备admin和user的权限&quot;); e.printStackTrace(); &#125; /*登出*/ subject.logout(); &#125;&#125; 具体流程与权限管理类似，只是授权认证的具体操作是交给Authorizer去调用相应的方法去检查Realm的授权信息，具体不展开。 由于上次权限管理采用的是SimpleAccountRealm这个简单的Realm实现类，没有权限的设置方法，既无法在初始化的时候，这是Bilii的具体权限，粒度在于角色。之后会有演示。 总结在授权管理中，为了便于项目维护，尽量使用用户-角色+角色-权限的设计思想，既显示角色。 用了两篇文章，分别介绍了授权和登录管理的简单实现。之后会整体利用Shiro+SSM简单实现一个简单的小项目。在该项目中，将会介绍到之前没有使用的自定义Realm和其他一些技术。","categories":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/tags/Shiro/"},{"name":"授权","slug":"授权","permalink":"https://bigbilii.github.io/tags/授权/"}]},{"title":"Shiro-权限管理","slug":"Shiro-权限管理","date":"2019-01-10T07:35:13.000Z","updated":"2019-01-12T06:29:56.809Z","comments":true,"path":"2019/01/10/Shiro-权限管理/","link":"","permalink":"https://bigbilii.github.io/2019/01/10/Shiro-权限管理/","excerpt":"","text":"前言昨天在写完Shiro-入门了解之后，了解了下【关联规则】的相关知识，其中涉及到的技术栈有Python、机器学习相关知识，但作为一个Java新手开发者，对这方面的了解甚少。所以已经将下面的技术提上了近期学习日程： Python快速入门上手：对于语言的学习不是关键，能够达到可以使用的程度就行 机器学习体系和相关知识学习：之前由于对机器学习的了解不多，所以会在之后学习下机器学习的体系和相关技术知识 关联分析算法实战：对于关联分析的相关算法进行学习和实战演练，如Apriori、FP-growth 权限管理言归正传，所谓权限管理，也就是身份验证，即在应用中证明操作的是本人。一般通过用户名/密码的方式来证明，也就是principals和Credentials组合方式。 所以需要的学术名词： Subject：主体，在上篇文章中做出过介绍，这里就不累述 Realms：安全数据连接对象，在上篇文章中做出过介绍，这里就不累述 Principals：身份，主体识别属性，可以是任何东西，如用户名、邮箱、手机号等，需要唯一。注意：一个主体可以有多个principals，但是能有一个Primary principals，例如姓名/手机号/用户名/邮箱等 Credentials：证书，用来验证机密数据，如密码/安全证书 在Shiro或则其他大多数的安全框架中，Java的验证过程可以拆分成下面三个步骤： 获取Subject的principals和credentials 将获取到的principals和credentials提交给验证系统 允许访问 | 重试验证 | 拒绝 在实际使用中，过程比上述复杂，但总体流程是这么回事。 简单例子为了直观的了解到Shiro如何进行权限管理。编写了下面一段测试代码。 依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 具体代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.bigbilii.test;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class AuthenticationTest &#123; /*简单的Realm*/ SimpleAccountRealm realm = new SimpleAccountRealm(); /*向Realm添加用户认证信息*/ @Before public void addUser() &#123; realm.addAccount(&quot;Bilii&quot;, &quot;123&quot;); &#125; @Test public void testAuthentication() &#123; /*1.构建SecurityManager环境*/ DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); /*2.添加Realm*/ defaultSecurityManager.setRealm(realm); /*3.主体提交认证信息*/ SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;Bilii&quot;, &quot;123&quot;); try &#123; /*4.登录（验证身份）*/ subject.login(token); &#125; catch (AuthenticationException e) &#123; /*5.登录失败*/ System.out.println(&quot;登录失败&quot;); e.printStackTrace(); &#125; Assert.assertEquals(true, subject.isAuthenticated()); /*6.登出*/ subject.logout(); &#125;&#125; 解释： 首先需要构建SecurityManager环境，这里使用的new实例化 添加Realm，由于是简单演示，所以采用的是SimpleAccountRealm，并提前利用addUser()方法来获得认证信息。除了上述方法，还有JdbcRealm、IniRealm等自带Realm，可以更加方便的使用数据库或者配置文件来读入认证信息。后面还会利用自定义Realm来获取认证信息 主体提交认证信息，通过工厂类，将SecurityManager实例化并绑定到SecurityUtils,并通过SecurityUtils的getSubject()方法来获取主体，绑定到当前线程。在将从前端获得的输入认证信息实例化成Token 登录，调用subject.login()方法登录。会调用SecurityManager.login()方法登录 登出，调用subject.logout()方法登录。会调用SecurityManager.logout()方法登录 总结上述例子，很简单，但也很清晰的描述了Shiro在认证管理时的工作流程。在实际Web项目开发中，都会结合Spring框架集成使用，Realm的逻辑也会更复杂，所以需要自定义Ream来实际结合业务逻辑，之后的文章会详细讲下如何在Spring中使用Shiro，以及数据库的建表注意事项。 参考Java Authentication Guide with Apache Shiro","categories":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/tags/Shiro/"},{"name":"权限管理","slug":"权限管理","permalink":"https://bigbilii.github.io/tags/权限管理/"}]},{"title":"Shiro-入门了解","slug":"Shiro-入门了解","date":"2019-01-09T08:49:43.000Z","updated":"2019-01-09T10:39:33.612Z","comments":true,"path":"2019/01/09/Shiro-入门了解/","link":"","permalink":"https://bigbilii.github.io/2019/01/09/Shiro-入门了解/","excerpt":"","text":"前言（废话）从泰国回来没几天，收到消息说我之前选的毕业设计题目没选上，导师通知我回学校确定题目。最终题目定下来了，是【基于关联规则的餐厅智能荐菜系统的研究与实现】。 其中的【关联规则】没接触过，需要接下来的时间去了解，但就题目而言，也就是一个餐厅点菜系统+个性化推荐。在3月份的开题报告之前，完成项目调查、分析和架构设计，同时也对数据挖掘或者机器学习方面做一些了解。 废话也不多说，接下来了解下Shiro，这个技术也会在我的毕业设计中使用。 简介Apache Shiro是Java的一个安全框架。其开源易用的特点，使得使用Shiro的人也是越来越多。 Shiro的主要功能如下： Authentication：身份认证，也就是我们日常使用的登录 Authorization：授权，也就是权限验证 Session Management：会话管理 Cache Management：缓存管理 cryptography：加密 架构从Shiro官方文档中，截取了下面的图片来了解下Shiro的核心架构。 Subject（org.apache.shiro.subject.Subject）： 主体，当前与软件交互的实体（用户、第三方服务等） SecurityManager（org.apache.shiro.mgt.SecurityManager）：Shiro的核心，SecurityManager管理则所有组件，所有具体交互都需要通过它进行控制 Authenticator（org.apache.shiro.authc.Authenticator）：认证器，负责主体的验证。当用户登录时，逻辑由Authenticator执行，并且Authenticator知道协调调用一个或多个Realms储存的用户/账号信息 Authrizer（org.apache.shiro.authz.Authorizer）：认证器，负责主体的权限验证操作。原理与认证器相识，也知道Realms储存的权限信息 SessionManager（org.apache.shiro.session.mgt.SessionManager）：会话控制器，用来管理Session的生命周期，提供强大的会话机制。可以在没有Web/Servlet或EJB容器中使用会话机制。 CacheManager（org.apache.shiro.cache.CacheManager）：缓存控制器，用来管理Cache的生命周期，提供为用户、角色、权限等的缓存机制，通过缓存来提高程序性能。 Cryptography（org.apache.shiro.crypto）密码模块，提供了一些常用的加密组件，用于比如密码的加密/解密 Realm（org.apache.shiro.realm.Realm）：Shiro和应用程序之间数据安全的【连接器】，由于Shiro并不知道用户/权限的存储方式和格式，一般需要用户自己实现Realm 了解到了Shiro的架构和组件，下一篇则会对Shiro的认证深入学习。 参考SHIRO simple. Java. Security","categories":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://bigbilii.github.io/tags/Shiro/"}]},{"title":"泰国旅游小记","slug":"泰国旅游小记","date":"2019-01-04T02:50:41.000Z","updated":"2019-01-04T03:52:51.303Z","comments":true,"path":"2019/01/04/泰国旅游小记/","link":"","permalink":"https://bigbilii.github.io/2019/01/04/泰国旅游小记/","excerpt":"","text":"“我们出去玩吧!”“去哪?”“泰国！” 半个月之前，一次短短的对话，定下了去泰国的行程。 出发之前由于之前的20多年时光中没有出国的经历，所以至今还没护照，故随即预约了下个工作日的护照办理。重庆的护照预约很方便，在微信公众号上预约时间和办理类型即可。 预约当天，到达了当地的出入境大厅。问了问工作人员流程，到了一个自助照相的地方。排队、照相、拿取凭证，简单高效的流程让人感到舒适。因为是工作日，所以当时办理事务的人不多，拿取预约号之后，很快就轮到我们办理护照了，填写了一些信息，录入了脸部和指纹信息，然后交180块费用，就办理完成了，凭借回执单，在下个星期的星期三（大约7-8个工作日）来领取就行。 总体而言，办理护照的流程和效率都是相当高的。 办理完护照之后，开始考虑自由行还是跟团。之前在国内旅游，都是自由行，但考虑到第一次出国，应对突发状况方面的经验欠缺，故考虑跟团。 在网上翻阅了很多旅行团的行程，大同小异，分为低价团、购物团和纯玩团，价格也是依次递增。由于我和我女朋友都是学生，而且也都不爱管家里要钱，所以选择了一个在重庆出发的购屋团，行程中由三个购物店。 由于我们是网上订的行程，也提前了大概有半个月订的，在和之后团员了解下来，同一个行程，我们订的是最贵的。 办了护照和定了行程，接着就是准备去旅游时需要的东西了。我们在网上租借了一个gopro，算下来8天只需要70多块钱，还是挺不错的。准备了衣服和药品，在银行换取了1w泰铢，准备出发了。 值得注意的是，之前在泰国大使馆查阅落地签需要的资料时，所需要携带的现金为每人1w泰铢（大致为2k人民币），而旅行社这边要求我们每人携带5k人民币，其目的是为了让我们能够多消费。 出发了出发当天，由于害怕被遣返，携带了接近8k人民币，到达机场之后，在领队约定的地方签到。遇到了跟我们同团的一对老年夫妇，他们大致70岁了，我女朋友小陈和他们攀谈时，了解到他们经常出去跟团旅游，也多次要求携带大量现金，但他们都没有携带。故小陈则放下心，去机场ATM将我们携带的现金存了进去，只携带了1W泰铢和2k人民币，符合泰国大使馆公布的要求。 在签到时，要求我们购买每人80元的交通险，由于我是第一次出来跟团，也觉得80块不多，故想买，但小陈觉得我们之前以及买过保险，所以在询问可以不买时，则没有买，之后询问老年夫妇，他们也没有买。 在机场处理好了相关信息之后，开始入关登记，重庆江北机场T3航站楼还是很先进的，大部分都是自助完成，过关很方便。 我们乘坐的是亚航的飞机，携带了20kg的托运和飞机餐，由于廉航，飞机座位对于我这个180cm身高的人来说有点打不直腿，三小时的飞行对我来说有点难受。 到达泰国，领队拿着我们的护照和填好的出入境卡去办理落地签，因为最近泰国免落地签费用，则人有点多，等待时间有点久。办好落地签之后，排队出关。途中没有人来检查现金，害的我们白担心一场。 曼谷 下了飞机。 脱下身上的大衣、羽绒服。 鼻子呼吸到了第一口空气，热、灰尘、干燥。 出了廊曼机场，接待我们的是导游和司机，带我们去了酒店。酒店还不错，干净、安静。周围有7-11和全家的便利店，能够买到一些吃的和生活用品。价格还算便宜。 我们的行程，大致可以简化成这样： 酒店-大巴-团队景点-大巴-酒店 而景点除了人有点多，还算不错。但是我更喜欢在大巴的时间。 在大巴车上看曼谷。 鲜艳的颜色，寺庙，皇家标志，日本车和皮卡车混成的巨大车流，高速路下的大量铁板搭建的贫民窟窟，在低楼中树立着设计独特的高楼。 这些非常符合我印象中的泰国。 这就是泰国。 芭提雅 情色表演，大量白人，海滩和太平洋，酒吧等，这些都是我对芭提雅这个地方的印象。 晚上的芭提雅才是芭提雅，夜空中的礼花和音乐声让这个城市变得躁动，随处可见的红灯区和酒吧，大量的酒精充满了街道。这些使小陈在街上走的时候，更加抱紧的我的手臂。 没有去酒吧，也没有洗泰浴，看了廉价的成人秀。 总结 第一次跟团，总的来说，花什么钱，旅什么游。 购物店无疑是最难受的行程，表面上是无需要强制购物，实则在第二天和第四天的行程中，导游的话术中，将购物绑架到了我们的身上，也很明显的感到，由于我们团队的购物水平不高，吃的东西也很差。 和小陈在海边的谈心很开心，虽然每天都有小吵架，但是我们都是喜欢着对方，每天都能和好。 活着，不是为了走遍全世界，也不是为了拥有什么东西，更不是需要成为什么样的人，活着就是活着。 去过一个景点，里面是泰国高僧的蜡像，每个蜡像旁，都会有高僧说的一句话，很遗憾的是当时没有记住那些话。但是唯一记住的，是他们的修行和思考，能够让他们成佛，让他们活着。 一次旅行，很高兴。小陈说她喜欢和我一起旅行，虽然旅行中会有吵架，但她还是喜欢和我一起旅行。 我也一样。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bigbilii.github.io/categories/随笔/"}],"tags":[{"name":"泰国","slug":"泰国","permalink":"https://bigbilii.github.io/tags/泰国/"},{"name":"旅游","slug":"旅游","permalink":"https://bigbilii.github.io/tags/旅游/"},{"name":"随笔","slug":"随笔","permalink":"https://bigbilii.github.io/tags/随笔/"}]},{"title":"Vagrant+VirtualBox搭建Linux开发环境","slug":"Vagrant-Virtualbox搭建Linux开发环境","date":"2019-01-03T07:02:37.000Z","updated":"2019-01-03T08:14:06.442Z","comments":true,"path":"2019/01/03/Vagrant-Virtualbox搭建Linux开发环境/","link":"","permalink":"https://bigbilii.github.io/2019/01/03/Vagrant-Virtualbox搭建Linux开发环境/","excerpt":"","text":"前言现在我是用的开发环境是windows 10。然而在我之前工作中，常常会项目部署在Linux环境中，所以在开发的时候，也会经常用到Linux环境。这次我就在我本地win10环境利用Vagrant+VirtualBox搭建一个Centos7的环境。 为什么选用Vagrant在我之前想要使用到Linux环境时，通常会使用虚拟机，如VirtualBox或者VMware，手动安装Linux系统和里面所需要的工作环境。 而使用Vagrant则可以省略上面的一些步骤，方便我们开发人员使用。 Vagrant提供了易于配置，可重复和编写的工作环境，基于行业标准技术构建，由单一一致的工作流程控制，以帮助你和你的团队最大限度地提高生产力和灵活性。 就开发人员而言，Vagrant可以大大简化我们平时配置环境的时间。只需要利用一个Vagrant文件，团队就可以创建出一个相同配置的开发环境，无论时Linux、Mac OS还是Windows。 环境搭建VirtualBox在官网下载自己环境的安装包。 我下载的是windows 6.0.0版本 下载好之后，直接安装完成即可。 Vagrant在官网下载好自己相应环境的安装包。 我下载的是windows 64位 2.2.2版本 初始化项目下载安装完成之后，在本地创建一个目录（如dev），进入目录，然后初始化项目。 12$ cd dev$ vagrant init 安装BOX使用以下命令，则可以直接从官网下载box文件，并启动。 12$ vagrant init centos/7$ vagrant up --provider virtualbox 如果下载速度慢，则可以从官网下载box文件，从本地加载。 123$ vagrant box add centos7 D:/software/boxes/centos-7.0-x86_64.box$ vagrant init centos7$ vagrant up 其他Linux发行版操作类似。 ssh登录通过vagrant up命令，启动了刚才安装的Centos7，则可以直接通过ssh来登录虚拟机了。 1$ vagrant ssh 注意：windows中的cmd命令行不能支持ssh，需要使用其他SSH客户端 注意：使用客户端，如xShell登录时，账户密码为vagrant，一般端口为2222或者2200 常用命令123456789101112131415vagrant box add 添加box的操作vagrant init 初始化box的操作，会生成vagrant的配置文件Vagrantfilevagrant up 启动本地环境vagrant ssh 通过 ssh 登录本地环境所在虚拟机vagrant halt 关闭本地环境vagrant suspend 暂停本地环境vagrant resume 恢复本地环境vagrant reload 修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）vagrant destroy 彻底移除本地环境vagrant box list 显示当前已经添加的box列表vagrant box remove 删除相应的boxvagrant package 打包命令，可以把当前的运行的虚拟机环境进行打包vagrant plugin 用于安装卸载插件vagrant status 获取当前虚拟机的状态vagrant global-status 显示当前用户Vagrant的所有环境状态","categories":[{"name":"Vagrant","slug":"Vagrant","permalink":"https://bigbilii.github.io/categories/Vagrant/"}],"tags":[{"name":"Vagrant","slug":"Vagrant","permalink":"https://bigbilii.github.io/tags/Vagrant/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://bigbilii.github.io/tags/VirtualBox/"},{"name":"Centos7","slug":"Centos7","permalink":"https://bigbilii.github.io/tags/Centos7/"}]},{"title":"2018年终小结","slug":"2018年终小结","date":"2018-12-25T09:16:13.000Z","updated":"2018-12-25T10:12:35.796Z","comments":true,"path":"2018/12/25/2018年终小结/","link":"","permalink":"https://bigbilii.github.io/2018/12/25/2018年终小结/","excerpt":"","text":"前言前几天把之前记的Maven笔记整理出来，之前也在学习Mybatis框架，可能会整理出文章来。 最近几天，在V2EX上看见有人讨论Linux发行版用哪个的问题，才发现我现在的开发环境没有Linux，随即开始着手搭建。用的是Vbox+Vagrant搭建的Centos7。之前在学校一直用的ubuntu，这次换了Centos，得好好习惯下。 流水账2018年底了，既然做了博客，就写篇年底总结来记录记录今年。下面开始流水账。 年初，作为大三下期的学生，课程当然很紧，每天课几乎都很多。但还是有空余时间，所以报了软考中级和六级考试。 到了期中，结了两门课，课程不是很多，但随即开始了3个课程设计和学校安排的实习，其中一个实习公司是Oracle。他们公司来宣讲的时候，准备了OCJP的免费考试名额作为奖励，通过考试获得，因为免费，所以没有犹豫的报名了，也顺利的拿到了名额。 5、6月份，完成了学习的课程设计，写好报告，完成了答辩。完成了软考中级，感觉良好。完成了OCJP考试，顺利通过。即将参加6级考试。参加了学校安排的生产实习，实习公司由学院安排，到的是培训机构进行实习。说是实习，其实更多像是培训，最终完成一个小组作品。这也是我第一次合作开发，学到了些东西。 期末，6级不出意外是挂了。由于感觉学校安排的实习不怎么样，我又想在秋招之前到公司实习下，故在网上投递简历。找了一家gis公司，在重庆主要和规划局做项目外包。在这家公司，实际接触到项目开发，由于不是互联网公司，作为Java开发的我，实际上做了环境搭建、部署，文档编写，测试，开发等多种工作。这也使我学到了很多东西，对项目开发的理解也具体化。 9月，在公司实习的我，想着开学之后就开始了秋招。所以一边完成工作的情况下，一边着手秋招的准备。投了一些公司，参加了百度、顺丰等的面试，但是由于一边实习，一边准备，没有准备太充分，所以效果都不太好，所以有了辞职的打算。 9月底，正式辞职，也就是9月底，收到猪八戒网的面试邀请，所以在家认真准备。面试非常愉快，面试官当场给我发了offer。由于猪八戒网在重庆还是很不错的公司，所以签约。 签约之后，是明年7月报道，可以提前实习。由于想在这段时间提升下自己和锻炼身体，所以没有去实习。在彻彻底底休息了一个月后，开始阅读和学习，之后搭建了博客。 总结这年，和女朋友在一起两年了，用实习工资把我的Xperia Z3换成了小米8，从水王、女流等主播那里收获了很多，喜欢上了阅读，找到了工作。 感觉自己在逐年提升，喜欢这个变化的过程，就像悉达多一样，经历，热爱。 2018年，很平常。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bigbilii.github.io/categories/随笔/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://bigbilii.github.io/tags/总结/"}]},{"title":"Maven依赖、聚合与继承","slug":"Maven依赖、聚合与继承","date":"2018-12-24T10:10:34.000Z","updated":"2018-12-24T11:27:19.627Z","comments":true,"path":"2018/12/24/Maven依赖、聚合与继承/","link":"","permalink":"https://bigbilii.github.io/2018/12/24/Maven依赖、聚合与继承/","excerpt":"","text":"依赖机制依赖管理是Maven的核心机制。可以管理数百个模块组成的多模块项目和应用程序的依赖关系。 Maven通过定义良好的ClassPath和library version，在定义、创建和维护可重现的构建方面提供大量帮助。 依赖范围依赖范围用于限制依赖关系的传递性，还用与各种构建任务的classpath。 Maven定义了三个classpath：编译、测试、运行 scope标签控制依赖与classpath的关系 compile：默认范围，对于编译、测试和运行三种classpath都有效。这些依赖项将传播到依赖项目。 provided：与compile很相似，但表示你希望JDK或容器运行时提供依赖关系。例如servlet-api。对于编译、测试的classpath有效，但对于运行无效，并且不可传递 runtime：对于运行和测试的classpath有效，编译无效。例如jdbc驱动。 test：对于测试classpath有效，对于编译和运行阶段无效，不具有传递性。 system：与provided相似，只是必须提供明确包含它的JAR，通过systemPath标签指出路径。 import：只能作用于&lt;dependencyManagement&gt;部分中的pom类型的依赖项。它用来替换依赖列表里的依赖项，不参与限制依赖的传递性。 依赖传递如果A项目依赖B项目，B项目依赖C项目，则形成了依赖传递，这样A项目也依赖C项目。 如果A项目不想依赖C项目，则在&lt;exlusions&gt;加入&lt;exlusion&gt;标签，标记C的坐标即可。 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;jline&lt;/groupId&gt; &lt;artifactId&gt;jline&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 依赖冲突在依赖中，依赖了同一个包的两个版本，则Maven根据短路优先原则参数依赖。 短路优先假设A项目中的依赖关系里，又两个X版本，依赖关系如下： 12A-&gt;B-&gt;C-&gt;X(jar)A-&gt;D-&gt;X(jar) 则会选择短的路径，即第二条。如果路径相同，则先生命优先。 聚合如果想一次构建多个项目模块，则可以对多个项目模块进行聚合。 如：12345&lt;modules&gt; &lt;module&gt;模块一&lt;/module&gt; &lt;module&gt;模块二&lt;/module&gt; &lt;module&gt;模块三&lt;/module&gt;&lt;/modules&gt; 继承为了消除重复，可以把配置信息提出。 如果需要继承某个项目，则在&lt;parent&gt;标签中添加父模块坐标（有必要时需要添加实际路径） 123456&lt;parent&gt; &lt;groupId&gt;公司名&lt;/groupId&gt; &lt;artifactId&gt;项目名&lt;/artifactId&gt; &lt;version&gt;版本&lt;/version&gt; &lt;relativePath&gt;实际路径&lt;/relativePath&gt;&lt;/parent&gt; 子模块继承了父模块的大量元素，但注意下面几项不会被继承 artifactId name prerequisites dependencyManagement由于子模块会继承父模块的全部依赖，为了方便子模块继承，父模块可以采用&lt;dependencyManagement&gt;进行管理，这样子模块就可以选择需要继承的依赖，不用全部继承依赖了。 123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencyManagement&gt; 参考Maven依赖管理","categories":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/categories/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/tags/Maven/"},{"name":"依赖","slug":"依赖","permalink":"https://bigbilii.github.io/tags/依赖/"}]},{"title":"Maven-pom常用元素","slug":"Maven-pom常用元素","date":"2018-12-21T03:01:11.000Z","updated":"2018-12-21T03:46:42.944Z","comments":true,"path":"2018/12/21/Maven-pom常用元素/","link":"","permalink":"https://bigbilii.github.io/2018/12/21/Maven-pom常用元素/","excerpt":"","text":"前言这次主要是对pom文件的一个解析，pom.xml文件作为项目对象模型，通过xml来表示一个Maven项目，是Maven的核心。 常用元素下面就主要对pom的常用元素进行解析。 其中，有些依赖、模块、继承等将在接下来的文章中介绍。 随不是完全对pom文件进行解析，但也是我在平时开发中常用到的一些元素，对下面元素有了深入了解，能够对付日常开发中的大部分问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!-- 标识xml文件版本号和编码方式 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- pom文件的根元素，主要声明了命名空间和xsd元素 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 所使用的object model版本，为了确保稳定的使用，这个元素是强制性的 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 坐标信息 --&gt; &lt;!-- 项目创建团体或组织的唯一标识符，通常为域名反写 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 项目的名字，通常为项目名+模块名 --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;!-- 第一个0表示大版本号 第二个0表示分支版本号 第三个0标识小版本号 0.0.1-SNAPSHOT snapshot快照 alpha内测 beta公测 Release稳定 GA正式发布 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 打包方式，默认为jar --&gt; &lt;packaging&gt;&lt;/packaging&gt; &lt;!-- END --&gt; &lt;!-- 用于Maven生成的文档中 --&gt; &lt;!-- 项目的展示名--&gt; &lt;name&gt;&lt;/name&gt; &lt;!-- 项目的地址 --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 项目描述 --&gt; &lt;description&gt;&lt;/description&gt; &lt;!-- 开发人员列表 --&gt; &lt;developers&gt;&lt;/developers&gt; &lt;!-- 许可证信息 --&gt; &lt;license&gt;&lt;/license&gt; &lt;!-- 组织信息 --&gt; &lt;organization&gt;&lt;/organization&gt; &lt;!-- END --&gt; &lt;!-- 属性定义 --&gt; &lt;properties&gt; &lt;!-- 项目编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- 编译JDK版本 --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- 自定义属性 --&gt; &lt;slf4j.version&gt;1.7.18&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 依赖列表 --&gt; &lt;dependencies&gt; &lt;!-- 依赖项 --&gt; &lt;dependency&gt; &lt;!-- 项目坐标 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 依赖范围 --&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- 设置依赖是否可选 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!--排除依赖传递列表 --&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!-- END --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 构建行为配置 --&gt; &lt;build&gt; &lt;!-- 插件管理 --&gt; &lt;pluginManagement&gt; &lt;!-- 插件列表 --&gt; &lt;plugins&gt; &lt;!-- 插件 --&gt; &lt;plugin&gt; &lt;!-- 坐标 --&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;!-- 父模块继承 --&gt; &lt;parent&gt;&lt;/parent&gt; &lt;!-- 多模块聚合 --&gt; &lt;modules&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/categories/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/tags/Maven/"},{"name":"Pom","slug":"Pom","permalink":"https://bigbilii.github.io/tags/Pom/"}]},{"title":"Maven的生命周期","slug":"Maven的生命周期","date":"2018-12-20T01:33:47.000Z","updated":"2018-12-20T02:32:46.325Z","comments":true,"path":"2018/12/20/Maven的生命周期/","link":"","permalink":"https://bigbilii.github.io/2018/12/20/Maven的生命周期/","excerpt":"","text":"Maven的功能之一是完成项目构建，而一个完整的项目构建过程包括：清理、编译、测试、打包、集成测试、验证、部署。所以Maven的生命周期中，概括了一个完整的项目构建过程。 Maven生命周期构建生命周期的几个阶段Maven中有三个内置的构建生命周期，clean、default、site。 clean 清理项目 pre-clean 执行清理前的工作 clean 清理上次构建生成的所有工作 post-clean 执行清理后的工作 default 构建项目（核心） 常用的有compile、test、package、install site 生成项目站点 pre-site 在生成项目站点之前要完成的工作 site 生成项目的站点文档 post-site 在生成项目站点后要完成的工作 site-deploy 发布生成站点到服务器上 生命周期的顺序是依次执行的，执行后面的步骤，会先去执行之前的步骤。 完整的生命周期列表，请参考Maven生命周期参考 某些阶段通常不会在命令行调用以连字符（pre-，post-，process-*）命名的阶段通常不会在命令行直接调用。这些阶段对构建进行排序，产生在构建之外无用的中间结果。比如在执行integration-test时，环境可能处于挂机状态。 设置项目在项目构建Maven构建时，如何给每个构建阶段分配任务？ 打包常用的方法时在POM元素packaging为项目设置打包。如jar，war，ear和pom，如果未设置，则默认为jar。 每个打包方式都包含一个绑定到特定阶段的目标列表。比如，jar打包的默认构建生命周期的阶段的绑定列表如下。 Phase plugin:goal process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package jar:jar install install:install deploy deploy:deploy 参考标准绑定集 插件可以通过添加插件的方式向项目中添加目标。插件也就是Maven提供目标的工具，每个插件的功能不同，具体可从官网查看。 比如，如果想生成Java源码，则可以使用Modello插件，将modello:java绑定到generate-sources阶段。则可以在POM文件中&lt;build&gt;的&lt;plugins&gt;部分插入以下内容： 1234567891011121314151617181920... &lt;plugin&gt; &lt;groupId&gt;org.codehaus.modello&lt;/groupId&gt; &lt;artifactId&gt;modello-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;models&gt; &lt;model&gt;src/main/mdo/maven.mdo&lt;/model&gt; &lt;/models&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;...","categories":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/categories/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/tags/Maven/"},{"name":"生命周期","slug":"生命周期","permalink":"https://bigbilii.github.io/tags/生命周期/"}]},{"title":"Maven中的坐标、仓库","slug":"Maven中的坐标、仓库","date":"2018-12-18T11:08:47.000Z","updated":"2018-12-18T12:05:01.652Z","comments":true,"path":"2018/12/18/Maven中的坐标、仓库/","link":"","permalink":"https://bigbilii.github.io/2018/12/18/Maven中的坐标、仓库/","excerpt":"","text":"坐标在Maven中，任何一个插件、项目输出都可以被称之为构建，所有构建都通过坐标作为其唯一标识。 大致由下面五个元素构成： groupId：一般为公司或组织的逆向域名。 artifactId：一般为项目名称+模块名称。 version：当前该Maven项目的版本。 packaging：Maven项目的打包方式，默认是jar，也可以打包成war, ear等。 classifier：定义一些附件，更加细化的后缀，用来定义比如源码、文档、x86版本、ios版本等。 前三个是必须定义，后两个视情况而定。 总之，每一个元素坐标，都是为了准确的找到一个构建而设定的。 仓库Maven中的仓库，用来存放构建，分为本地仓库和远程仓库 如果在所依赖的构建在本地仓库中没有查找到，则会去远程仓库(默认为maven远程中央仓库)中下载。 修改本地仓库在安装目录下的conf文件夹中，打开settings.xml文件。找到localRepository，在3.6.0版本中，会有下面一段注解，意思就是本地仓库默认在${user.home}/.m2/repository下，如果需要修改，则添加&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;这个标签，里面的值为你设置的本地仓库路径。 1234567&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;你的本地仓库路径&lt;/localRepository&gt; 镜像仓库由于maven的中央仓库设置在国外，访问和下载速度很慢，则可以设置一个国内的镜像仓库，这样就能直接从国内的镜像仓库中下载所需要的构建了。 在安装目录下的conf文件夹中，打开settings.xml文件。找到mirrors，添加相应内容即可。 镜像仓库就相当于个拦截器，它会拦截maven对远程仓库的请求，将请求的地址重定向到&lt;url&gt;标签所配置的地址，所拦截的范围为&lt;mirrorOf&gt;标签所配置的内容，拦截范围内容为仓库ID，可设置多个，用 , 隔开，也可以用 ! 设置不用拦截仓库id。 123456789101112131415161718192021&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云镜像 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/categories/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/tags/Maven/"},{"name":"仓库","slug":"仓库","permalink":"https://bigbilii.github.io/tags/仓库/"},{"name":"镜像","slug":"镜像","permalink":"https://bigbilii.github.io/tags/镜像/"},{"name":"坐标","slug":"坐标","permalink":"https://bigbilii.github.io/tags/坐标/"}]},{"title":"Maven入门","slug":"Maven入门","date":"2018-12-16T06:44:31.000Z","updated":"2018-12-16T07:30:35.807Z","comments":true,"path":"2018/12/16/Maven入门/","link":"","permalink":"https://bigbilii.github.io/2018/12/16/Maven入门/","excerpt":"","text":"MavenMaven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。 环境搭建本次将在windows环境下搭建maven环境。 注意：环境中需要配置JDK 下载Maven访问Maven官网,下载你所需要的版本，一般情况下，下载已编译的版本，然后解压到相应的安装目录下。 目录结构介绍： bin：包含mvn的运行脚本 boot：一个类加载器的框架 conf：配置文件目录 lib：mvn平时所用的类库 配置环境变量下载解压安装好之后，需要进行环境变量的配置，以便在任何路径下都能执行mvn的相应运行脚本。 打开环境变量，编辑系统变量（如果此电脑由多用户使用，则编辑用户变量） 新建，变量名M2_HOME，变量值为maven的安装目录，确定。 编辑Path，增加%M2_HOME%\\bin;，确定。 配置成功，打开命令行，输入mvn -v可以查看到maven的版本，Java信息和系统信息。 打开环境变量步骤：电脑邮件-属性-高级系统设置-环境变量。安装目录下最好不要有中文路径，以避免不必要的问题。 Maven目录结构良好的目录结构，有助于开发人员理解项目，也能更好的维护项目。 一般的Maven项目目录结构 12345678910|--pom.xml //项目对象模型配置文件|--src |--main |--java //源代码 `package |--resources //资源文件 |--test |--java //测试代码 `package |--resources //测试资源文件 Maven常用命令123456mvn -v //查看maven版本mvm compile //编译mvn test //测试mvn package //打包mvn clean //删除targetmvn install //安装jar包到本地仓库 创建目录的两种方式 arhetype:gennerate //按照提示进行选择 arhetype:gennerate -DgroupId=组织名，公司网址反写 -DartifactId=项目名-模块名 -Dversion=版本号 -Dversion=版本号 -Dpackage=代码存在的包名","categories":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/categories/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://bigbilii.github.io/tags/Maven/"}]},{"title":"Hexo主题NexT配置","slug":"Hexo主题NexT配置","date":"2018-12-10T12:37:09.000Z","updated":"2018-12-10T14:06:45.986Z","comments":true,"path":"2018/12/10/Hexo主题NexT配置/","link":"","permalink":"https://bigbilii.github.io/2018/12/10/Hexo主题NexT配置/","excerpt":"","text":"上篇博客配置了Hexo，今天这篇文章，将介绍Hexo配置NexT主题的配置。 NexT主题下载与启动使用git，克隆最新版本，下载到/themes目录下。 12$ cd username.github.io$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载好之后，打开站点配置文件(/_config.yml),找到theme字段，将值改为next。 1theme: next 重新启动hexo站点，即可看到主题改变。 注：配置其他主题也是一样的步骤 注：如果没有看到主题改变，清理下缓存，使用hexo clean命令，再重试 配置站点配置文件站点配置文件在根目录下的_congif.yml 站点信息设置12345title: #站点名称subtitle: #副标题description: #站点描述author: #昵称language: #语言设置 注意：NexT主题中，language配置有相应的配置信息。 语言 代码 设定示例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt or language: pt-BR 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id Korean ko language: ko 配置主题配置文件主题配置文件在主题目录下的/themes/next/_congif.yml 选择SchemeScheme是NexT提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。 取消想要使用的效果前面的#注释，即可开启，，123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 设置菜单通过配置menu标签，来设置网址的菜单选项。 用法：key: link || icon key为菜单项名称，如果在配置的language中翻译项能找到对应翻译，则使用翻译，如果不能找到，则使用key。 link为菜单的链接。 icon为FontAwesome图标的名称，如果不配置，则默认使用问题图标。 menu_icons配置是否使用icon。1234567891011121314151617# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 注：如果站点在子目录下运行，则link的最前面的/删除。 注：默认菜单项为上面列出的，只有home和archives不需要手动创建，其他均需要手动创建。 设置头像修改avatar字段，值为头像链接，链接可以为：12# Sidebar Avatar http://example.com/avatar.png 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 站点建立时间这个时间将在站点的底部显示，例如 ©2018。 编辑主题配置文件，新增字段since。 1since: 2018 Valine评论配置leancloudValine需要运行在leancloud上，所以需要注册其账号，创建一个应用（名字随意），进入应用，设置，应用Key，找到App ID和App Key。 配置NexT主题配置文件打开主题配置文件（/themes/_config.yml），找到Valine标签（没有可自行添加），配置如下。12345678910valine: enable: true appid: #上面的appid appkey: #上面的appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 欢迎评论 # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail # custom comment header pageSize: 10 # pagination size 阅读次数统计（LeanCloud)配置leancloud在配置Valine评论系统的时候，已经拥有了leancloud账号，如果没有，则可以跳转上去查看。 创建应用(名字随意）点击左侧右上角的齿轮图标，新建Class：此处的新建Class名字必须为Counter。 由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。 与valine上述一样，获取该应用的App ID和App Key。 配置NexT主题配置文件打开主题配置文件（/themes/next/_config.yml），找到leancloud_visitors标签（没有可自行添加），配置如下。1234leancloud_visitors: enable: true app_id: #上面的appid app_key: #上面的appkey Local Search安装插件安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save 配置站点信息在/config.yml中添加12345search: path: search.xml field: post format: html limit: 10000 配置主题信息在/themes/next/config.yml中,启动本地搜索123# Local searchlocal_search: enable: true 参考NexT官方文档","categories":[{"name":"博客","slug":"博客","permalink":"https://bigbilii.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://bigbilii.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://bigbilii.github.io/tags/博客/"},{"name":"NexT","slug":"NexT","permalink":"https://bigbilii.github.io/tags/NexT/"}]},{"title":"Hexo+Github博客搭建","slug":"Hexo-Github博客搭建","date":"2018-12-05T08:22:31.000Z","updated":"2018-12-05T09:07:01.984Z","comments":true,"path":"2018/12/05/Hexo-Github博客搭建/","link":"","permalink":"https://bigbilii.github.io/2018/12/05/Hexo-Github博客搭建/","excerpt":"","text":"hexo是快速、简洁且高效的博客框架，本文章介绍如何利用hexo+github搭建出一个静态博客网站。 环境搭建node.js在官网下载你相应环境的node.js，根据提示进行安装。 检验安装完成： $ node -v git在官网下载相应环境的git，根据提示安装。 安装成功后，配置相应的账号和邮箱。（这里需要github账号） 12$ git config --global user.name &quot;username&quot;$ git config --global user.email username@gmail.com hexo安装node.js之后，根据官网的提示，安装hexo。 1$ npm install hexo-cli -g 搭建本地博客创建博客目录上面三个环境搭建好之后，在本地的终端中，进入某个路径，在该路径下建立博客目录。123$ hexo init username.github.io$ cd username.github.io$ npm install 生成静态页面并运行123$ hexo clean$ hexo g$ hexo s g 即generates 即server 在浏览器中，输入地址 localhost:4000 即可看到效果。 这样一个本地的hexo博客系统以及搭建好了。 部署到Github创建一个username.github.io的public仓库创建一个仓库，根据你的github的username来创建一个public的仓库，仓库名为username.github.io 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 配置git在本地站点配置文件的：_config.yml 文件中配置deploy1234deploy: type: git repo: &lt;repository url&gt; branch: master 发布1$ hexo d 这样就能在username.github.com中看到你的博客系统了。","categories":[{"name":"博客","slug":"博客","permalink":"https://bigbilii.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://bigbilii.github.io/tags/hexo/"},{"name":"Github","slug":"Github","permalink":"https://bigbilii.github.io/tags/Github/"},{"name":"博客","slug":"博客","permalink":"https://bigbilii.github.io/tags/博客/"}]},{"title":"起于年末的片头","slug":"起于年末的片头","date":"2018-12-04T14:40:01.000Z","updated":"2018-12-04T14:40:37.560Z","comments":true,"path":"2018/12/04/起于年末的片头/","link":"","permalink":"https://bigbilii.github.io/2018/12/04/起于年末的片头/","excerpt":"","text":"今日，2018年12月4日，是2018年的结束，是我的开始。 回顾我，今年23岁，现目前就读于重庆理工大学，计算机科学与技术专业，大四上半学期。在今年暑假加入某gis公司实习，秋招的时候，顺利收到猪八戒网的Java开发offer。 在过去的很多年内，有很多想法，做过动漫视频剪辑，做过博客，跑步，摄影，看书。但几乎都是做了头两次，但没有坚持，原因就是，当把这些所谓的兴趣和想法，以质量的形式来衡量，就失去了做下去的动力。也就是说，当我想把某件事做好，那么需要很多精力和时间去做这件事，这件事就不再使我快乐，成为了我的负担，也就作罢。 当现目前我有了足够多的时间，距离明年工作报道还有半年多的时间，这使我重拾了以前的兴趣之一，博客。 现状现目前的我，是一名计算机专业的学生，和其他程序员一样，热爱着技术和科技。 目前是一名Java开发者，手头也有一些Java相关的技术书籍，掌握了Java基础，Web开发和Spring等相关框架的使用，在实习的时候也学习了Mongodb、Elasticsearch等的使用，在学校也学习了前端，C语言，算法，Andorid，计算机系统，单片机，计算机网络等课程，取得了软件设计师（软考中级），OCJP认证。 规划时间，是我现在所富裕的。所以我得好好计划下接下来的时间安排。 在接下来的时间，我有几个计划 坚持学习技术，记笔记，更新博客 每周跑步两次，锻炼身体，保护头发 坚持看书（非技术类），增长知识，方便吹b 在明年年后，租到适合的房子 不过，现目前还在大学，还有最后的毕业设计要做，等待开题中，等完成了就彻底轻松了，可以出去旅游旅游。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bigbilii.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://bigbilii.github.io/tags/随笔/"},{"name":"生活","slug":"生活","permalink":"https://bigbilii.github.io/tags/生活/"}]}]}